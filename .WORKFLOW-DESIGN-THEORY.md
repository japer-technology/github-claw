# Workflow Design Theory

An analysis of the GitHub Actions workflows defined in this repository, their effects, and the design principles they embody.

---

## Workflows Overview

This repository defines two GitHub Actions workflows that operate as a complementary pair:

| Workflow | File | Purpose |
|---|---|---|
| **GITCLAW-WORKFLOW-AGENT** | `.github/workflows/GITCLAW-WORKFLOW-AGENT.yml` | Runs the AI agent in response to issues and comments |
| **GITCLAW Installer** | `.github/workflows/GITCLAW-INSTALLER.yml` | Bootstraps the repository with workflows, templates, and configuration |

Each workflow also has a source-of-truth copy inside `.GITCLAW/`:
- `.GITCLAW/install/GITCLAW-WORKFLOW-AGENT.yml` â€” template used during installation
- `.GITCLAW/GITCLAW-INSTALLER.yml` â€” master copy of the installer

---

## Workflow 1: GITCLAW-WORKFLOW-AGENT

### Trigger Events

```yaml
on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]
```

The agent activates on two GitHub events: when a new issue is opened, and when a comment is posted on any issue. A conditional filter prevents the workflow from re-triggering on its own bot comments (`github-actions[bot]`), avoiding infinite feedback loops.

### Effect

This workflow transforms every GitHub issue into a live conversational interface with an AI agent. Its net effect is:

1. **A user opens an issue or posts a comment** â†’ the workflow starts.
2. **Authorization gate** â€” The actor's repository permission is verified via the GitHub API. Only collaborators with `write`, `maintain`, or `admin` permission are allowed through. Unauthorized users cause the workflow to fail immediately, preventing public abuse on open repositories.
3. **Fail-closed sentinel guard** (`GITCLAW-ENABLED.ts`) â€” Checks for the existence of `.GITCLAW/GITCLAW-ENABLED.md`. If the file is absent, the entire workflow halts. This means the agent is disabled by default on any fresh clone until the operator deliberately opts in by ensuring the sentinel file is present.
4. **Heart guard** (`GITCLAW-HEART-GUARD.ts`) â€” An optional gate that, when activated (by renaming `GITCLAW-HEART-NOT-REQUIRED.md` to `GITCLAW-HEART-REQUIRED.md`), requires new issues to contain a â¤ï¸ emoji in their body. This only applies to `issues.opened` events; follow-up comments are always processed. When disabled (the default), all issues pass through.
5. **Activity indicator** (`GITCLAW-INDICATOR.ts`) â€” Adds a ğŸ‘€ reaction to the triggering issue or comment, providing immediate visual feedback that the agent is working. The reaction metadata is persisted to `/tmp/reaction-state.json` for cleanup later.
6. **Dependency installation** â€” Runs `bun install --frozen-lockfile` inside `.GITCLAW/` to install the `pi` agent binary and its dependencies.
7. **Agent execution** (`GITCLAW-AGENT.ts`) â€” The core orchestrator that:
   - Fetches the full issue title and body from the GitHub API.
   - Resolves or creates a session mapping (`state/issues/<number>.json` â†’ `state/sessions/<timestamp>.jsonl`) to maintain conversation continuity across workflow runs.
   - Builds a prompt from the event context.
   - Validates that the required LLM API key is present (posts a diagnostic comment if missing).
   - Runs the `pi` AI agent binary, streaming output through `tee` for real-time logging.
   - Extracts the agent's final text reply from the JSONL output.
   - Commits and pushes all state changes (session transcripts, file edits) back to the default branch with a retry-on-conflict loop (up to 3 attempts with `--rebase`).
   - Posts the agent's reply as a comment on the originating issue, capped at 60,000 characters.
   - In a `finally` block, removes the ğŸ‘€ reaction to signal completion regardless of success or failure.

### Design Principles

- **Fail-closed security**: The workflow does nothing unless explicitly enabled. Two independent guards (authorization + sentinel file) must both pass before any agent logic executes.
- **Idempotent session state**: Each issue maps to exactly one session file. Resuming a conversation loads the prior transcript, giving the agent full memory of earlier exchanges.
- **Git-native persistence**: All conversation history and state changes are committed to the repository. There is no external database â€” the git log is the audit trail.
- **Graceful degradation**: Reaction failures are non-fatal. Missing API keys produce a helpful diagnostic comment rather than a silent failure. Push conflicts are retried with rebasing.
- **Zero pre-install dependencies**: The guard scripts (`GITCLAW-ENABLED.ts`, `GITCLAW-HEART-GUARD.ts`, `GITCLAW-INDICATOR.ts`) use only Node.js built-ins and the `gh` CLI, so they run before `bun install` without external packages.

### Permissions

```yaml
permissions:
  contents: write   # commit and push state/session changes and file edits
  issues: write     # post comments and manage reactions
  actions: write    # allow downstream workflow triggers
```

---

## Workflow 2: GITCLAW Installer (Bootstrap)

### Trigger Events

```yaml
on:
  workflow_dispatch:        # manual trigger with configurable inputs
  push:
    paths:
      - '.github/workflows/GITCLAW-INSTALLER.yml'
  workflow_run:
    workflows:
      - 'GITCLAW-WORKFLOW-AGENT'
    types:
      - completed
```

The installer activates in three scenarios:
1. **Manual dispatch** â€” An operator clicks "Run workflow" in the Actions tab, optionally configuring overwrite behavior and Node.js version.
2. **Self-modification** â€” A push that changes the installer workflow file itself triggers a re-run, ensuring the bootstrap stays current.
3. **Post-agent sync** â€” After every completed run of GITCLAW-WORKFLOW-AGENT, the installer runs to ensure any agent-generated workflow changes are properly installed. A guard (`github.actor != 'github-actions[bot]'`) prevents the installer from triggering on its own commits.

### Effect

This workflow transforms the `.GITCLAW/install/` directory into a fully operational GitHub repository configuration. Its net effect is:

1. **Branch creation** â€” Creates a timestamped branch (`gitclaw/bootstrap-YYYYMMDD-HHMMSS`) to isolate bootstrap changes from the main branch.
2. **Workflow installation with runtime conversion** â€” Copies all `.yml`/`.yaml` files from `.GITCLAW/install/` to `.github/workflows/`, performing an automatic Bun-to-Node/npm conversion:
   - `oven-sh/setup-bun` â†’ `actions/setup-node@v4`
   - `bun-version` â†’ `node-version`
   - `bun install --frozen-lockfile` â†’ `npm ci`
   - `bun <file>.ts` â†’ `npx tsx <file>.ts`
   - `bun <file>.js` â†’ `node <file>.js`
   - `bun test` â†’ `npm test`
   - `bun run` â†’ `npm run`

   This conversion allows the `.GITCLAW/` source directory to use Bun natively during development while producing Node.js-compatible workflows for repositories that prefer npm.
3. **`.gitignore` management** â€” Merges ignore rules from `.GITCLAW/.gitignore` or `.GITCLAW/gitignore` into the repository's `.gitignore`, wrapped in marker comments (`# --- GITCLAW managed rules ---`) for idempotent updates. Previous managed blocks are removed before re-adding.
4. **Issue template installation** â€” Copies files matching `GITCLAW-TEMPLATE-*` from `.GITCLAW/install/` to `.github/ISSUE_TEMPLATE/`, providing standardized issue forms (e.g., the Hatch template for personality bootstrapping).
5. **Config file installation** â€” Copies optional configuration files (`.editorconfig`, `.nvmrc`, `.npmrc`, `.eslintrc*`, `.prettierrc*`) from `.GITCLAW/` to the repository root, and executable scripts from `.GITCLAW/scripts/` to `scripts/`.
6. **Installation marker** â€” Renames `.GITCLAW/GITCLAW-NOT-INSTALLED.md` to `.GITCLAW/GITCLAW-INSTALLED.md` to record that the bootstrap has completed.
7. **Pull request creation** â€” If any changes were made, commits them and opens a pull request against the default branch with a descriptive body listing all changes. This ensures bootstrap changes are reviewed before merging.

### Design Principles

- **Non-destructive by default**: Existing files are never overwritten unless the operator explicitly sets `overwrite: true`. This respects any customizations the user has already made.
- **Idempotent execution**: The installer can run repeatedly. Marker comments in `.gitignore` are replaced cleanly. The installation marker prevents redundant renames. Already-existing files are skipped with notices.
- **Review-first delivery**: Changes are delivered via pull request, not direct pushes to the default branch. This gives the operator a chance to inspect, modify, or reject the bootstrap before it takes effect.
- **Runtime portability**: The Bun-to-npm conversion means the development environment (Bun) and the deployment environment (Node.js/npm) can differ without manual file editing.
- **Self-healing**: The `workflow_run` trigger after every agent run means if the agent creates or modifies workflow templates, the installer automatically picks up and installs them.

### Permissions

```yaml
permissions:
  contents: write        # commit bootstrap changes to the new branch
  pull-requests: write   # create the review PR
```

---

## How the Workflows Interact

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   User opens an issue     â”‚
                    â”‚   or posts a comment      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  GITCLAW-WORKFLOW-AGENT      â”‚
                â”‚                             â”‚
                â”‚  1. Authorize actor          â”‚
                â”‚  2. Guard (sentinel file)    â”‚
                â”‚  3. Heart guard (optional)   â”‚
                â”‚  4. Add ğŸ‘€ indicator         â”‚
                â”‚  5. Install dependencies     â”‚
                â”‚  6. Run AI agent             â”‚
                â”‚  7. Commit state + push      â”‚
                â”‚  8. Post reply comment       â”‚
                â”‚  9. Remove ğŸ‘€ indicator      â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ (on completed)
                          â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  GITCLAW-INSTALLER          â”‚
                â”‚                             â”‚
                â”‚  1. Create bootstrap branch  â”‚
                â”‚  2. Install workflows (bunâ†’npm) â”‚
                â”‚  3. Merge .gitignore rules   â”‚
                â”‚  4. Copy issue templates     â”‚
                â”‚  5. Copy config files        â”‚
                â”‚  6. Mark installed           â”‚
                â”‚  7. Open review PR           â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The GITCLAW-WORKFLOW-AGENT workflow triggers the GITCLAW-INSTALLER workflow upon completion. This creates a cascading pipeline where the agent's work (which may include changes to workflow templates or configuration) is automatically bootstrapped into the repository's GitHub integration layer.

The installer's `github.actor != 'github-actions[bot]'` guard prevents this chain from becoming an infinite loop â€” the installer's own commits do not re-trigger itself.

---

## Lifecycle Script Architecture

The GITCLAW-WORKFLOW-AGENT workflow orchestrates four lifecycle scripts in strict sequential order. Each script is designed to run independently with zero third-party dependencies (prior to `bun install`), using only Node.js built-ins and the `gh` CLI.

| Order | Script | Purpose | Failure Effect |
|---|---|---|---|
| 1 | `GITCLAW-ENABLED.ts` | Verify opt-in sentinel exists | Workflow halts (fail-closed) |
| 2 | `GITCLAW-HEART-GUARD.ts` | Optional heart emoji requirement | Workflow halts if heart missing and required |
| 3 | `GITCLAW-INDICATOR.ts` | Add ğŸ‘€ reaction indicator | Non-fatal; agent still runs |
| 4 | `GITCLAW-AGENT.ts` | Run the AI agent and post reply | Agent error; ğŸ‘€ still cleaned up via `finally` |

This ordering ensures:
- Guards execute before any expensive operations (dependency installation, LLM API calls).
- The activity indicator appears as early as possible for user feedback.
- Cleanup is guaranteed regardless of where a failure occurs.

---

## Security Model

The workflows implement defense in depth through multiple independent layers:

1. **Actor authorization** â€” The first step in the agent workflow checks the triggering user's repository permission via the GitHub API. Only `write`, `maintain`, and `admin` collaborators proceed.
2. **Fail-closed sentinel** â€” The `GITCLAW-ENABLED.md` file must exist for the agent to run. Deleting this file instantly disables all agent automation without removing any code.
3. **Bot loop prevention** â€” Both workflows filter out actions from `github-actions[bot]` to prevent infinite trigger loops.
4. **Heart gate** â€” An optional additional layer requiring a deliberate emoji in the issue body, useful for rate-limiting or confirming intent.
5. **Scoped permissions** â€” Each workflow requests only the minimum GitHub token permissions needed for its operations.
6. **Non-destructive installation** â€” The installer never overwrites existing files by default, and delivers changes via PR for human review.

---

## State Model

All state is stored in the git repository itself, following the "repository is the application" philosophy:

```
.GITCLAW/state/
  issues/
    <number>.json           # Maps issue number â†’ session file path
  sessions/
    <timestamp>_<id>.jsonl  # Full conversation transcript (JSONL format)
```

- **Issue mappings** are stable keys: issue #N always resolves to the same session, enabling multi-turn conversations across days or weeks.
- **Session transcripts** are append-only JSONL files that the `pi` agent reads to restore context on resumption.
- **Git history** serves as the audit log: every agent interaction, file edit, and state change is a versioned commit.
- **Merge safety**: `.gitattributes` configures `memory.log merge=union` so that the agent's append-only memory log (a separate file from session transcripts) uses union merge, preventing conflicts when parallel agent runs append entries concurrently.

---

## Summary

The two workflows form a self-reinforcing system: the **agent workflow** provides the conversational AI interface through GitHub Issues, while the **installer workflow** ensures the repository infrastructure stays synchronized with the agent's evolving configuration. Together they implement a fully autonomous AI agent platform that requires zero external infrastructure â€” the repository itself serves as compute (Actions), storage (Git), interface (Issues), and identity (permissions).
